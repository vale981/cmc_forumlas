#+PROPERTY: header-args :session basic_estimates :kernel python :pandoc no :async yes :noweb yes

This is some quik-n-dirty code to get some rough numbers.
I'm not proud of it, but it does the job.

I neglect the shifts in the diagonals of the capactance matrix for
now, as they're all very minor.

* Boilerplate
Setup code and module imports
#+begin_src jupyter-python
  import numpy as np
  import pint
  from math import *
  from cmc_formulas import *
  import cmc_formulas.typical_values as T
  from cmc_formulas.typical_values import *
#+end_src

#+RESULTS:


* Typical Values
Here, we print the typical values that i've taken from
[cite:@Blais2004] and [cite:@Gao2021a].

** Resonator
#+begin_src jupyter-python
  T.CPW
#+end_src

#+RESULTS:
: namespace(Z_r=50 <Unit('ohm')>,
:           v_0=130000000.0 <Unit('meter / second')>,
:           d=1 <Unit('centimeter')>,
:           l=153846.15384615381 <Unit('femtofarad / meter')>,
:           c=384.6153846153846 <Unit('nanohenry / meter')>,
:           C_r=1538.461538461538 <Unit('femtofarad')>,
:           L_r=3.846153846153846 <Unit('nanohenry')>,
:           ω_0=7.5398223686155035 <Unit('gigahertz')>)

#+begin_src jupyter-python
  T.CPW.ω_0 = Q_(1.2, "gigahertz") * 2 * np.pi
#+end_src

#+RESULTS:

** Qubit
#+begin_src jupyter-python
  T.Transmon
#+end_src

#+RESULTS:
: namespace(E_C=200 <Unit('dirac_constant * megahertz * pi')>,
:           E_J=10000 <Unit('dirac_constant * megahertz * pi')>,
:           C_Σ=193.70229324659127 <Unit('femtofarad')>,
:           ω_q=11.938052083641214 <Unit('gigahertz')>,
:           α=0.6283185307179586 <Unit('gigahertz')>)


#+begin_src jupyter-python
  T.Transmon.ω_q / (2*np.pi)
#+end_src

#+RESULTS:
:RESULTS:
1.9 gigahertz
:END:

#+begin_src jupyter-python
(T.Transmon.E_J/T.Transmon.E_C).to(ureg.dimensionless)
#+end_src

#+RESULTS:
:RESULTS:
50.0 dimensionless
:END:


#+begin_src jupyter-python
  formulas.ω_p(T.Transmon.E_C, T.Transmon.E_J) / (2*np.pi)
#+end_src

#+RESULTS:
:RESULTS:
2.0 gigahertz
:END:



* Our Qubit
Let's make a standard transmon with a ratio of \(E_J/E_C= 50\) and a
frequency of \(\SI{5}{\giga\hertz}\).
#+begin_src jupyter-python
  transmon = T.TransmonQubit.from_angular_frequency_and_transmon_ratio(5 * ureg.gigahertz * 2 * np.pi, 50)
  print(transmon.overview())
#+end_src

#+RESULTS:
: ω:      31.41592653589793 gigahertz
: ω/2π:   5.0 gigahertz
: E_J:    82.67349088394192 dirac_constant * gigahertz
: E_C:    1.6534698176788385 dirac_constant * gigahertz
: f_J:    13.157894736842106 gigahertz * planck_constant
: f_C:    0.2631578947368421 gigahertz * planck_constant
: ratio:  50.0 dimensionless


* Bus CPW
I'm just eyeballing this for now, but the bus should be below the
qubit so that we have some leeway with tuning the qubit interaction
and the readout strength.

#+begin_src jupyter-python
  bus = T.CoplanarWaveguide(length = 1.5 * ureg.cm)
  bus.f
#+end_src

#+RESULTS:
:RESULTS:
4.333333333333334 gigahertz
:END:

This produces a detuning
#+begin_src jupyter-python
  transmon.Δ(bus)
#+end_src

#+RESULTS:
:RESULTS:
4.18879020478639 gigahertz
:END:

The coherence time of Transmons in on the order of
\(\SI{1}{\micro\second}\) [cite:@Blais2021], so that the oscillation
half-time \(T_{1/2}\) time in [[id:694996d4-b387-4591-830f-6181fedc81a8][The Model for the CMC Project]] should be
shorter than that.

#+begin_src jupyter-python :results none
  T_12 = 1 * ureg.microsecond
#+end_src

With this we can calculate the coupling capacitance between Transmon
and bus.

#+begin_src jupyter-python
  cc = formulas.C_c(T_12, transmon.C_Σ, transmon.E_J, bus.ω)
  cc
#+end_src

#+RESULTS:
:RESULTS:
0.8889520149652524 femtofarad
:END:

The corresponding oscillator/qubit coupling strength \(g\) is
#+begin_src jupyter-python
  transmon.g(bus, cc)
#+end_src

#+RESULTS:
:RESULTS:
0.08111557351947217 gigahertz
:END:

This is is well below the detuning
#+begin_src jupyter-python
  transmon.g(bus, cc) / transmon.Δ(bus)
#+end_src

#+RESULTS:
:RESULTS:
0.019364916731037074 dimensionless
:END:



It is important to keep \(C_c\ll C_Σ,C_B\) and \(g\ll \abs{Δ}\lesssim ω_q +
ω_B\). Otherwise, everything variale.
Also, the anharmonicity is much smaller than \(Δ\). Basically
everything in the following should be small (\(\sim .01\)).

#+begin_src jupyter-python
print(T.dispersive_metrics(transmon, bus, cc))
#+end_src

#+RESULTS:
: {'Anharmonicity, α/Δ': 0.3947368421052633, 'Coupling Strength, g/Δ': 0.019364916731037074, 'RWA counter-rotating': 0.0714285714285714, 'Coupling/Transmon Cap': 0.012077024843609918, 'Coupling/CPW Cap': 0.00038521253981827614}


As we can see, there is a lot of play in most things, but the
anharmonicity may be reduced. This can be done either by reducing the
qubit frequency while keeping the detuning constant or decreasing the
transmon ratio \(E_J/E_C\).


* Drive
The readout's restriction is the anharmonicity, although this
constraint is weak, as we can use DRAG [cite:@Blais2021].

The question is: what is a typical pulse amplitude?
I've found numbers in [cite:@Bardin] that say \(\SIrange{50}{500}{\micro\volt}\)
are normal.

This is the (rough) limit on the coupling to the drive.
#+begin_src jupyter-python
  formulas.C_d_max(T.Transmon.E_C, T.Transmon.E_J, T.V_Dmax)
#+end_src

#+RESULTS:
:RESULTS:
0.35825758655858 femtofarad
:END:

This is much smaller than the coupling to the bus and corresponds to
drive times that are much greater than
#+begin_src jupyter-python
  (2 * np.pi / T.Transmon.α).to(ureg.microsecond)
#+end_src

#+RESULTS:
:RESULTS:
0.01 microsecond
:END:

which is still \(1/10\) of \(T_{1/2}\). This could get tight, but
thanks to DRAG this shouldn't be a big problem. Maybe we can also
detune the Qubit before flipping it.



* Readout
The readout should be *above* the qubit in frequency!!!!! This is /really/
important (see christobals talk). Basically
